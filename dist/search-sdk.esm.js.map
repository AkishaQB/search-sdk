{"version":3,"file":"search-sdk.esm.js","sources":["../src/cache.js","../src/client.js","../src/rateLimiter.js","../src/debounce.js","../src/http.js"],"sourcesContent":["export class Cache {\n  constructor(ttlMs) {\n    this.ttlMs = ttlMs;\n    this.store = new Map();\n  }\n\n  set(key, value) {\n    const expiresAt = Date.now() + this.ttlMs;\n\n    this.store.set(key, {\n      value,\n      expiresAt\n    });\n  }\n\n  get(key) {\n    const entry = this.store.get(key);\n\n    if (!entry) return undefined;\n\n    if (Date.now() > entry.expiresAt) {\n      this.store.delete(key);\n      return undefined;\n    }\n\n    return entry.value;\n  }\n}\n","import { debounce } from \"./debounce.js\";\nimport { createRateLimiter } from \"./rateLimiter.js\";\nimport { Cache } from \"./cache.js\";\nimport { request } from \"./http.js\";\n\nexport function createSearchClient({\n  debounceMs,\n  maxCalls,\n  interval,\n  cacheTtl\n}) {\n  const limiter = createRateLimiter({\n    max: maxCalls,\n    interval\n  });\n\n  const cache = new Cache(cacheTtl);\n\n  const execute = async (url, query) => {\n    // 1️⃣ Cache first (fastest path)\n    const cached = cache.get(query);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // 2️⃣ Fail fast on rate limit\n    if (!limiter.acquire()) {\n      throw new Error(\"Rate limit exceeded\");\n    }\n\n    // 3️⃣ Network call\n    const result = await request(`${url}?q=${encodeURIComponent(query)}`);\n\n    // 4️⃣ Store in cache\n    cache.set(query, result);\n\n    return result;\n  };\n\n  // 5️⃣ Debounced public API\n  return debounce(execute, debounceMs);\n}\n","\n/** Token Bucket mental model \nImagine a bucket:\n\nCapacity = max\nTokens refill over time\nEach request consumes 1 token\nNo token → reject */\n\n\nexport function createRateLimiter({ max, interval }) {\n  let tokens = max;\n  let lastRefill = Date.now();\n\n  const refillRate = max / interval; // tokens per ms\n\n  return {\n    acquire() {\n      const now = Date.now();\n      const elapsed = now - lastRefill;\n\n      // Refill tokens based on time passed\n      tokens = Math.min(max, tokens + elapsed * refillRate);\n      lastRefill = now;\n\n      if (tokens >= 1) {\n        tokens -= 1;\n        return true;\n      }\n\n      return false;\n    }\n  };\n}\n","/**generate a debounce utility\n * parameters function, delay\n *  */ \n\n\nexport function debounce(fn, delay = 200) {\n    let timerId = null;\n\n    function debounced(...args) {\n        const context = this;\n        timerId = setTimeout(() => {\n            fn.apply(context, args)\n            timerId = null;\n        }, delay)\n\n    }\n    debounced.cancel = function () {\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n  };\n    return debounced;\n}","export async function request(url, options = {}) {\n  const {\n    headers = {},\n    ...rest\n  } = options;\n\n  const res = await fetch(url, {\n    ...rest,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers\n    }\n  });\n\n  let data;\n  try {\n    data = await res.json();\n  } catch {\n    data = null;\n  }\n\n  if (!res.ok) {\n    const error = new Error(`HTTP ${res.status}`);\n    error.status = res.status;\n    error.body = data;\n    throw error;\n  }\n\n  return data;\n}\n"],"names":["Cache","constructor","ttlMs","this","store","Map","set","key","value","expiresAt","Date","now","get","entry","delete","createSearchClient","debounceMs","maxCalls","interval","cacheTtl","limiter","max","tokens","lastRefill","refillRate","acquire","elapsed","Math","min","createRateLimiter","cache","fn","delay","timerId","debounced","args","context","setTimeout","apply","cancel","clearTimeout","debounce","async","url","query","cached","undefined","Error","result","options","headers","rest","res","fetch","data","json","ok","error","status","body","request","encodeURIComponent"],"mappings":"AAAO,MAAMA,EACX,WAAAC,CAAYC,GACVC,KAAKD,MAAQA,EACbC,KAAKC,MAAQ,IAAIC,GACnB,CAEA,GAAAC,CAAIC,EAAKC,GACP,MAAMC,EAAYC,KAAKC,MAAQR,KAAKD,MAEpCC,KAAKC,MAAME,IAAIC,EAAK,CAClBC,QACAC,aAEJ,CAEA,GAAAG,CAAIL,GACF,MAAMM,EAAQV,KAAKC,MAAMQ,IAAIL,GAE7B,GAAKM,EAAL,CAEA,KAAIH,KAAKC,MAAQE,EAAMJ,WAKvB,OAAOI,EAAML,MAJXL,KAAKC,MAAMU,OAAOP,EAHQ,CAQ9B,ECrBK,SAASQ,GAAmBC,WACjCA,EAAUC,SACVA,EAAQC,SACRA,EAAQC,SACRA,IAEA,MAAMC,ECDD,UAA2BC,IAAEA,EAAGH,SAAEA,IACvC,IAAII,EAASD,EACTE,EAAab,KAAKC,MAEtB,MAAMa,EAAaH,EAAMH,EAEzB,MAAO,CACL,OAAAO,GACE,MAAMd,EAAMD,KAAKC,MACXe,EAAUf,EAAMY,EAMtB,OAHAD,EAASK,KAAKC,IAAIP,EAAKC,EAASI,EAAUF,GAC1CD,EAAaZ,EAETW,GAAU,IACZA,GAAU,GACH,EAIX,EAEJ,CDtBkBO,CAAkB,CAChCR,IAAKJ,EACLC,aAGIY,EAAQ,IAAI9B,EAAMmB,GAwBxB,OEnCK,SAAkBY,EAAIC,EAAQ,KACjC,IAAIC,EAAU,KAEd,SAASC,KAAaC,GAClB,MAAMC,EAAUjC,KAChB8B,EAAUI,WAAW,KACjBN,EAAGO,MAAMF,EAASD,GAClBF,EAAU,MACXD,EAEP,CAOA,OANAE,EAAUK,OAAS,WACfN,IACFO,aAAaP,GACbA,EAAU,KAEd,EACSC,CACX,CFiBSO,CAtBSC,MAAOC,EAAKC,KAE1B,MAAMC,EAASf,EAAMlB,IAAIgC,GACzB,QAAeE,IAAXD,EACF,OAAOA,EAIT,IAAKzB,EAAQK,UACX,MAAM,IAAIsB,MAAM,uBAIlB,MAAMC,QG/BHN,eAAuBC,EAAKM,EAAU,IAC3C,MAAMC,QACJA,EAAU,CAAA,KACPC,GACDF,EAEEG,QAAYC,MAAMV,EAAK,IACxBQ,EACHD,QAAS,CACP,eAAgB,sBACbA,KAIP,IAAII,EACJ,IACEA,QAAaF,EAAIG,MACnB,CAAE,MACAD,EAAO,IACT,CAEA,IAAKF,EAAII,GAAI,CACX,MAAMC,EAAQ,IAAIV,MAAM,QAAQK,EAAIM,UAGpC,MAFAD,EAAMC,OAASN,EAAIM,OACnBD,EAAME,KAAOL,EACPG,CACR,CAEA,OAAOH,CACT,CHEyBM,CAAQ,GAAGjB,OAASkB,mBAAmBjB,MAK5D,OAFAd,EAAMxB,IAAIsC,EAAOI,GAEVA,GAIgBhC,EAC3B"}